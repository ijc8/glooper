<!DOCTYPE html>
<html>
<head>
  <title>WebSocket demo</title>
</head>
<body>
  <script>
   var ws = new WebSocket("ws://127.0.0.1:8765/");
   ws.binaryType = 'arraybuffer';

   ws.onopen = function(event) {
     const node = document.getElementById("input");
     node.addEventListener("keyup", function(event) {
       if (event.key === "Enter") {
         sendMessage(node.value);
       }
     });
   }

   ws.onmessage = function(e) {
     var packet = parsePacket(e.data);
     if (packet.type === 'audio') {
       processChunk(packet.data);
     } else if (packet.type === 'message') {
       showMessage(`${packet.user}: ${packet.message}`);
     } else if (packet.type === 'join') {
       showMessage(`${packet.user} has arrived! :-)`);
     } else if (packet.type === 'leave') {
       showMessage(`${packet.user} has departed. :-(`);
     }
   }

   ws.onclose = function(e) {
     if (micProcessor) micProcessor.disconnect();
     if (remoteProcessor) remoteProcessor.disconnect();
   }

   // Protocol types.
   const AUDIO = 0;
   const MESSAGE = 1;
   const OBJECT = 2;

   function parsePacket(raw) {
     let tag = (new DataView(raw)).getUint32(0, true);
     let payload = new Uint8Array((new Uint8Array(raw)).buffer, 4);
     if (tag == AUDIO) {
       let data = new Float32Array(payload.buffer);
       return {type: 'audio', data};
     } else if (tag == OBJECT) {
       let str = new TextDecoder("utf-8").decode(payload);
       console.log(str);
       let obj = JSON.parse(str);
       return obj;
     }
     console.log(`error: unknown tag ${tag}`);
     return null;
   }

   function sendMessage(msg) {
     var strbuf = new TextEncoder("utf-8").encode(msg);
     var packet = new Uint8Array(strbuf.length + 4);
     packet.subarray(4).set(strbuf);
     (new DataView(packet.buffer)).setUint32(0, MESSAGE, true);
     console.log(packet);
     ws.send(packet);
   }

   function showMessage(msg) {
     console.log(msg);
     var messages = document.getElementsByTagName('ul')[0],
         message = document.createElement('li'),
         content = document.createTextNode(msg);
     message.appendChild(content);
     messages.appendChild(message);
     document.body.appendChild(messages);
   }

   function sendChunk(chunk) {
     var packet = new Uint8Array(chunk.buffer.byteLength + 4);
     packet.subarray(4).set(new Uint8Array(chunk.buffer));
     (new Uint32Array(packet.buffer))[0] = AUDIO;
     ws.send(packet);
   }

   var queue = [];
   function processChunk(chunk) {
     queue.push(chunk);
   }

   // create web audio api context
   var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
   var micProcessor;

   const bufferSize = 512;

   const handleSuccess = function(stream) {
     // Got permission to use the mic - upload samples to server.
     const source = audioCtx.createMediaStreamSource(stream);
     micProcessor = audioCtx.createScriptProcessor(bufferSize, 1, 0);

     source.connect(micProcessor);
     micProcessor.connect(audioCtx.destination);

     micProcessor.onaudioprocess = function(e) {
       let data = e.inputBuffer.getChannelData(0);
       //sendChunk(data);
       if (recordingPos >= 0) {
         console.log(recordingPos);
         console.log(data);
         recordingBuffer.copyToChannel(data, 0, recordingPos);
         recordingPos += data.length;
       }
     };
   };

   navigator.mediaDevices.getUserMedia({ audio: true, video: false })
       .then(handleSuccess);

   // Play received data from server.
   remoteProcessor = audioCtx.createScriptProcessor(bufferSize, 0, 1);
   remoteProcessor.onaudioprocess = function (e) {
     if (queue.length) {
       e.outputBuffer.copyToChannel(queue.shift(), 0);
     } else {
       console.log("audio underrun!");
     }
   }

   var recordingPos = -1;
   var recordingBuffer = audioCtx.createBuffer(1, 5 * audioCtx.sampleRate, audioCtx.sampleRate);

   function record() {
     console.log("start recording");
     recordingPos = 0;
     setTimeout(function () {
       console.log("stop recording");
       recordingPos = -1;
       let bufferSource = audioCtx.createBufferSource();
       bufferSource.buffer = recordingBuffer;
       bufferSource.loop = true;
       bufferSource.connect(audioCtx.destination);
       bufferSource.start(0);
     }, 5000);
   }

   remoteProcessor.connect(audioCtx.destination);
  </script>
  <input id="recording-name" type="text" />
  <button onclick="record()">Record</button>
  <ul style="border: 1px solid black"></ul>
  Chat: <input id="input" type="text" /><br/>
</body>
</html>
