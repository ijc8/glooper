<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <style>
   #tape-length {

   };
  </style>

  <title>WebSocket demo</title>
</head>
<body class="bg-light">
  <script>
   /* var ws = new WebSocket("ws://127.0.0.1:8765/");
    * ws.binaryType = 'arraybuffer';

    * ws.onopen = function(event) {
    *   const node = document.getElementById("input");
    *   node.addEventListener("keyup", function(event) {
    *     if (event.key === "Enter") {
    *       sendMessage(node.value);
    *     }
    *   });
    * }

    * ws.onmessage = function(e) {
    *   var packet = parsePacket(e.data);
    *   if (packet.type === 'audio') {
    *     processChunk(packet.data);
    *   } else if (packet.type === 'message') {
    *     showMessage(`${packet.user}: ${packet.message}`);
    *   } else if (packet.type === 'join') {
    *     showMessage(`${packet.user} has arrived! :-)`);
    *   } else if (packet.type === 'leave') {
    *     showMessage(`${packet.user} has departed. :-(`);
    *   }
    * }

    * ws.onclose = function(e) {
    *   if (micProcessor) micProcessor.disconnect();
    *   if (remoteProcessor) remoteProcessor.disconnect();
    * }

    * // Protocol types.
    * const AUDIO = 0;
    * const MESSAGE = 1;
    * const OBJECT = 2;

    * function parsePacket(raw) {
    *   let tag = (new DataView(raw)).getUint32(0, true);
    *   let payload = new Uint8Array((new Uint8Array(raw)).buffer, 4);
    *   if (tag == AUDIO) {
    *     let data = new Float32Array(payload.buffer);
    *     return {type: 'audio', data};
    *   } else if (tag == OBJECT) {
    *     let str = new TextDecoder("utf-8").decode(payload);
    *     console.log(str);
    *     let obj = JSON.parse(str);
    *     return obj;
    *   }
    *   console.log(`error: unknown tag ${tag}`);
    *   return null;
    * }

    * function sendMessage(msg) {
    *   var strbuf = new TextEncoder("utf-8").encode(msg);
    *   var packet = new Uint8Array(strbuf.length + 4);
    *   packet.subarray(4).set(strbuf);
    *   (new DataView(packet.buffer)).setUint32(0, MESSAGE, true);
    *   console.log(packet);
    *   ws.send(packet);
    * }

    * function showMessage(msg) {
    *   console.log(msg);
    *   var messages = document.getElementsByTagName('ul')[0],
    *       message = document.createElement('li'),
    *       content = document.createTextNode(msg);
    *   message.appendChild(content);
    *   messages.appendChild(message);
    *   document.body.appendChild(messages);
    * }

    * function sendChunk(chunk) {
    *   var packet = new Uint8Array(chunk.buffer.byteLength + 4);
    *   packet.subarray(4).set(new Uint8Array(chunk.buffer));
    *   (new Uint32Array(packet.buffer))[0] = AUDIO;
    *   ws.send(packet);
    * }

    * var queue = [];
    * function processChunk(chunk) {
    *   queue.push(chunk);
    * }

      // Play received data from server.
      /* remoteProcessor = audioCtx.createScriptProcessor(bufferSize, 0, 1);
    * remoteProcessor.onaudioprocess = function (e) {
    *   if (queue.length) {
    *     e.outputBuffer.copyToChannel(queue.shift(), 0);
    *   } else {
    *     console.log("audio underrun!");
    *   }
    * }

      remoteProcessor.connect(audioCtx.destination);
    */

   // Wild idea: what if the playback rate doubles as the recording rate?
   // so you can record at different rates, record backwards, etc.
   // then slider bubble can simply turn red for recording
   // Special case: if playback rate is 0 when you hit record, automatically change to 1?
   // Alternative terminology: 'loops' vs 'tapes'
   // Name idea: grouper looper. group's loops. etc.
   // Note: AudioBufferSourceNode.playbackRate is an AudioParam!
   // So is detune. Interesting.
   // TODO: make the playback rate fields work.
   // TODO: track playback position using audioCtx.currentTime, update sliders.
   // TODO: websocket server for sharing tapes.

   let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
   let microphone;
   let micProcessor;

   const bufferSize = 0;

   const handleSuccess = (stream) => {
     // Got permission to use the mic; start processing samples.
     microphone = audioCtx.createMediaStreamSource(stream);
     /*micProcessor = audioCtx.createScriptProcessor(bufferSize, 1, 0);

     microphone.connect(micProcessor);

     micProcessor.onaudioprocess = function(e) {
       let data = e.inputBuffer.getChannelData(0);
       //sendChunk(data);
       if (recordingPos >= 0 && recordingPos < recordingBuffer.length) {
         recordingBuffer.copyToChannel(data, 0, recordingPos);
         recordingPos += data.length;
       }
     };*/
   };

   navigator.mediaDevices.getUserMedia({ audio: true, video: false })
       .then(handleSuccess);

   // buffer, source, rate, startTime, startPos.
   let tapes = {};

   function createTape() {
     // To satisfy Chrome's demands:
     if (audioCtx.state === "suspended")
       audioCtx.resume().then(_createTape);
     else
       _createTape();
   }

   // TODO make this an actual class
   function getPos(tape) {
     let pos = ((audioCtx.currentTime - tape.startTime) * tape.rate + tape.startPos);
     return pos % tape.buffer.duration;
   }

   function setRate(tape, rate) {
     // Reset startPos and startTime since we're changing playbackRate. Order matters.
     tape.startPos = getPos(tape);
     tape.startTime = audioCtx.currentTime;

     tape.rate = rate;

     if (rate < 0) {
       // TODO Workaround this.
       console.log("negative playback rates not supported by web audio...");
     } else if (rate === 0) {
       // Also not supported, but here's a workaround.
       if (tape.source) {
         tape.source.disconnect();
         tape.source = null;
       }
     } else {
       if (!tape.source) {
         let source = audioCtx.createBufferSource();
         source.buffer = tape.buffer;
         source.loop = true;
         source.connect(audioCtx.destination);
         source.start(0);
         tape.source = source;
       }
       tape.source.playbackRate.value = rate;
     }
   }

   function _createTape() {
     let name = document.getElementById("tape-name").value;
     let length = parseFloat(document.getElementById("tape-length").value);
     console.log(name, length);
     let buffer = audioCtx.createBuffer(1, length * audioCtx.sampleRate, audioCtx.sampleRate);
     let tape = {
       buffer: buffer,
       source: null,
       rate: 0,
       startTime: audioCtx.currentTime,
       startPos: 0
     };
     tapes[name] = tape;

     // Create new table entry from template.
     let table = document.getElementById("tape-table");
     let template = document.getElementById("tape-row-template");
     let entry = template.cloneNode(true);
     entry.hidden = false;
     entry.id = "";
     entry.getElementsByClassName("tape-name")[0].innerHTML = name;
     entry.getElementsByClassName("tape-length")[0].innerHTML = length;
     let pos = entry.getElementsByClassName("tape-position")[0];
     pos.id = `${name}-position`;
     let rate = entry.getElementsByClassName("tape-rate")[0];
     rate.value = 0;
     rate.onchange = (e) => {
       let value = parseFloat(e.target.value);
       setRate(tape, value);
     }
     table.appendChild(entry);

     // Add new source and destination options.
     for (let id of ["record-src", "record-dst"]) {
      let select = document.getElementById(id);
      let option = document.createElement("option");
      option.innerHTML = name;
      select.appendChild(option);
     }
   }

   var hmm = null;

   function record() {
     console.log("start recording");
     let srcSelect = document.getElementById("record-src");
     let dstSelect = document.getElementById("record-dst");
     let src = null;
     let dst = dstSelect.options[dstSelect.selectedIndex].text;
     if (srcSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else if (srcSelect.selectedIndex === 1) {
       src = microphone;
     } else {
       src = tapes[srcSelect.options[srcSelect.selectedIndex].text].source;
     }

     if (dstSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else {
       dst = tapes[dstSelect.options[dstSelect.selectedIndex].text];
     }

     // Chrome bug requires us to add a dummy output:
     // https://bugs.chromium.org/p/chromium/issues/detail?id=327649#c15
     recorder = audioCtx.createScriptProcessor(bufferSize, 1, 1);
     recorder.connect(audioCtx.destination);
     hmm = recorder;
     console.log(hmm);

     let pos = 0;
     recorder.onaudioprocess = (e) => {
       // TODO Allow recording to start anywhere, handle wrapping,
       // and maybe make stopping recording a separate action.
       if (pos > dst.buffer.length) {
         console.log('stop recording');
         src.disconnect(recorder);
         recorder.disconnect();

         // Browsers differ re. modifying the source's buffer, so let's just do this:
         if (dst.source) {
           dst.source.disconnect();
           dst.source = null;
         }
         setRate(dst, dst.rate);
         return;
       }
       let data = e.inputBuffer.getChannelData(0);
       dst.buffer.copyToChannel(data, 0, pos);
       pos += data.length;
     };

     src.connect(recorder);
   }

   function updatePositions() {
     for (let name in tapes) {
       console.log(name);
       let tape = tapes[name];
       let slider = document.getElementById(`${name}-position`);
       let time = audioCtx.currentTime;
       slider.value = getPos(tape) / tape.buffer.duration * parseFloat(slider.max);
     }
     setTimeout(updatePositions, 30);
   }

   updatePositions();
  </script>
  <div class="container mt-4">
    <form>
      <div class="form-row align-items-center">
        <input id="tape-name" type="text" class="col-4 form-control my-1 mr-2" placeholder="Name" />
        <input id="tape-length" class="col-4 form-control my-1 mr-2" type="number" placeholder="Length (seconds)" />
        <button type="button" class="col-2 form-control btn btn-success" onclick="createTape()">Create tape</button><br/>
      </div>
    </form>
    <form>
      <div class="form-row align-items-center">
        <select id="record-src" class="col-4 form-control custom-select my-1 mr-2" placeholder="From">
          <option value="" disabled selected>Source</option>
          <option>Microphone</option>
        </select>
        <select id="record-dst" class="col-4 custom-select my-1 mr-2" placeholder="To">
          <option value="" disabled selected>Destination</option>
        </select>
        <button type="button" class="col-2 form-control btn btn-danger" onclick="record()">Record</button><br/>
      </div>
    </form>
    <hr>
    <h2>Tapes</h2>
    <table class="table">
      <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Position</th>
          <th scope="col">Length</th>
          <th scope="col">Playback Rate</th>
        </tr>
      </thead>
      <tbody id="tape-table">
        <tr id="tape-row-template" hidden>
          <th class="tape-name" scope="row">Foobar</th>
          <td><input type="range" class="tape-position custom-range" min="0" max="1000"></td>
          <td class="tape-length">5</td>
          <td><input class="tape-rate" type="number"></td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- for bootstrap -->
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
