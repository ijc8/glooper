<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <style>
   #tape-length {

   };
  </style>

  <title>WebSocket demo</title>
</head>
<body class="bg-light">
  <script>
   var ws = new WebSocket("ws://127.0.0.1:8765/");
   ws.binaryType = 'arraybuffer';

   ws.onopen = function(event) {
     console.log("connected");
   }

   ws.onmessage = function(e) {
     receiveTape(JSON.parse(e.data));
   }

   function _arrayBufferToBase64(buffer) {
     var binary = '';
     var bytes = new Uint8Array(buffer);
     var len = bytes.byteLength;
     for (var i = 0; i < len; i++) {
       binary += String.fromCharCode(bytes[ i ]);
     }
     return window.btoa(binary);
   }

   function _base64ToArrayBuffer(base64) {
     var binary_string = window.atob(base64);
     var len = binary_string.length;
     var bytes = new Uint8Array(len);
     for (let i = 0; i < len; i++) {
       bytes[i] = binary_string.charCodeAt(i);
     }
     return bytes.buffer;
   }

   var hmm1, hmm2;
   function receiveTape(t) {
     console.log("receiveTape");
     console.log(t);
     let name = t.name;
     console.log(`received string of length ${t.data.length}`);
     hmm1 = _base64ToArrayBuffer(t.data);
     console.log(hmm1);
     let data = new Float32Array(_base64ToArrayBuffer(t.data));
     console.log(`received buffer of size ${data.length}`);
     let buffer = audioCtx.createBuffer(1, data.length, audioCtx.sampleRate);
     buffer.copyToChannel(data, 0);
     let tape = {
       buffer,
       source: null,
       rate: 0,
       startPos: 0,
       startTime: audioCtx.currentTime
     }
     tapes[name] = tape;
     addTape(name, tape);
   }

   function sendTape(name, tape) {
     console.log("sendTape");
     // very inefficient encoding
     let encoded = _arrayBufferToBase64(tape.buffer.getChannelData(0).buffer);
     let serializable = {
       name,
       data: encoded
     }
     ws.send(JSON.stringify(serializable));
   }

   // Wild idea: what if the playback rate doubles as the recording rate?
   // so you can record at different rates, record backwards, etc.
   // then slider bubble can simply turn red for recording
   // Special case: if playback rate is 0 when you hit record, automatically change to 1?
   // Alternative terminology: 'loops' vs 'tapes'
   // Name idea: grouper looper. group's loops. etc.
   // Note: AudioBufferSourceNode.playbackRate is an AudioParam!
   // So is detune. Interesting.
   // TODO: websocket server for sharing tapes.
   // TODO: better audio encoding to avoid, possibly chunked tape transfer.

   // when tape is created or recorded, send to the server an object with the tape name and data.
   // the server sends this to each client.
   // when the client receives a new tape from the server, it adds it to the local list.

   let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
   let microphone;
   let micProcessor;

   const bufferSize = 0;

   const handleSuccess = (stream) => {
     microphone = audioCtx.createMediaStreamSource(stream);
   };

   navigator.mediaDevices.getUserMedia({ audio: true, video: false })
       .then(handleSuccess);

   // buffer, source, rate, startTime, startPos.
   let tapes = {};

   function createTape() {
     // To satisfy Chrome's demands:
     if (audioCtx.state === "suspended")
       audioCtx.resume().then(_createTape);
     else
       _createTape();
   }

   // TODO make this an actual class
   function getPos(tape) {
     let pos = ((audioCtx.currentTime - tape.startTime) * tape.rate + tape.startPos);
     return pos % tape.buffer.duration;
   }

   function setRate(tape, rate) {
     // Reset startPos and startTime since we're changing playbackRate. Order matters.
     tape.startPos = getPos(tape);
     tape.startTime = audioCtx.currentTime;

     tape.rate = rate;

     if (rate < 0) {
       // TODO Workaround this.
       console.log("negative playback rates not supported by web audio...");
     } else if (rate === 0) {
       // Also not supported, but here's a workaround.
       if (tape.source) {
         tape.source.disconnect();
         tape.source = null;
       }
     } else {
       if (!tape.source) {
         let source = audioCtx.createBufferSource();
         source.buffer = tape.buffer;
         source.loop = true;
         source.connect(audioCtx.destination);
         source.start(0);
         tape.source = source;
       }
       tape.source.playbackRate.value = rate;
     }
   }

   function _createTape() {
     let name = document.getElementById("tape-name").value;
     let length = parseFloat(document.getElementById("tape-length").value);
     console.log(name, length);
     let buffer = audioCtx.createBuffer(1, length * audioCtx.sampleRate, audioCtx.sampleRate);
     let tape = {
       buffer: buffer,
       source: null,
       rate: 0,
       startTime: audioCtx.currentTime,
       startPos: 0
     };
     tapes[name] = tape;
     sendTape(name, tape);
     addTape(name, tape);
   }

   function addTape(name, tape) {
     let length = tape.buffer.duration;
     // Create new table entry from template.
     let table = document.getElementById("tape-table");
     let template = document.getElementById("tape-row-template");
     let entry = template.cloneNode(true);
     entry.hidden = false;
     entry.id = "";
     entry.getElementsByClassName("tape-name")[0].innerHTML = name;
     entry.getElementsByClassName("tape-length")[0].innerHTML = length;
     let pos = entry.getElementsByClassName("tape-position")[0];
     pos.id = `${name}-position`;
     let rate = entry.getElementsByClassName("tape-rate")[0];
     rate.value = tape.rate;
     rate.onchange = (e) => {
       let value = parseFloat(e.target.value);
       setRate(tape, value);
     }
     table.appendChild(entry);

     // Add new source and destination options.
     for (let id of ["record-src", "record-dst"]) {
      let select = document.getElementById(id);
      let option = document.createElement("option");
      option.innerHTML = name;
      select.appendChild(option);
     }
   }

   function record() {
     console.log("start recording");
     let srcSelect = document.getElementById("record-src");
     let dstSelect = document.getElementById("record-dst");
     let src = null;
     let dst = dstSelect.options[dstSelect.selectedIndex].text;
     let dstName = "";
     if (srcSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else if (srcSelect.selectedIndex === 1) {
       src = microphone;
     } else {
       src = tapes[srcSelect.options[srcSelect.selectedIndex].text].source;
     }

     if (dstSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else {
       dstName = dstSelect.options[dstSelect.selectedIndex].text;
       dst = tapes[dstName];
     }

     // Chrome bug requires us to add a dummy output:
     // https://bugs.chromium.org/p/chromium/issues/detail?id=327649#c15
     recorder = audioCtx.createScriptProcessor(bufferSize, 1, 1);
     recorder.connect(audioCtx.destination);
     src.connect(recorder);

     let pos = 0;
     recorder.onaudioprocess = (e) => {
       // TODO Allow recording to start anywhere, handle wrapping,
       // and maybe make stopping recording a separate action.
       if (pos > dst.buffer.length) {
         console.log('stop recording');
         src.disconnect(recorder);
         recorder.disconnect();
         recorder.onaudioprocess = null;

         // Browsers differ re. modifying the source's buffer, so let's just do this:
         if (dst.source) {
           dst.source.disconnect();
           dst.source = null;
         }
         setRate(dst, dst.rate);
         sendTape(dstName, dst);
         return;
       }
       let data = e.inputBuffer.getChannelData(0);
       dst.buffer.copyToChannel(data, 0, pos);
       pos += data.length;
     };
   }

   function updatePositions() {
     for (let name in tapes) {
       let tape = tapes[name];
       let slider = document.getElementById(`${name}-position`);
       let time = audioCtx.currentTime;
       slider.value = getPos(tape) / tape.buffer.duration * parseFloat(slider.max);
     }
     setTimeout(updatePositions, 30);
   }

   updatePositions();
  </script>
  <div class="container mt-4">
    <form>
      <div class="form-row align-items-center">
        <input id="tape-name" type="text" class="col-4 form-control my-1 mr-2" placeholder="Name" />
        <input id="tape-length" class="col-4 form-control my-1 mr-2" type="number" placeholder="Length (seconds)" />
        <button type="button" class="col-2 form-control btn btn-success" onclick="createTape()">Create tape</button><br/>
      </div>
    </form>
    <form>
      <div class="form-row align-items-center">
        <select id="record-src" class="col-4 form-control custom-select my-1 mr-2" placeholder="From">
          <option value="" disabled selected>Source</option>
          <option>Microphone</option>
        </select>
        <select id="record-dst" class="col-4 custom-select my-1 mr-2" placeholder="To">
          <option value="" disabled selected>Destination</option>
        </select>
        <button type="button" class="col-2 form-control btn btn-danger" onclick="record()">Record</button><br/>
      </div>
    </form>
    <hr>
    <h2>Tapes</h2>
    <table class="table">
      <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Position</th>
          <th scope="col">Length</th>
          <th scope="col">Playback Rate</th>
        </tr>
      </thead>
      <tbody id="tape-table">
        <tr id="tape-row-template" hidden>
          <th class="tape-name" scope="row">Foobar</th>
          <td><input type="range" class="tape-position custom-range" min="0" max="1000"></td>
          <td class="tape-length">5</td>
          <td><input class="tape-rate" type="number"></td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- for bootstrap -->
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
