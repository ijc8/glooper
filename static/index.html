<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="bootstrap.min.css">

  <style>
   .recording-range::-webkit-slider-thumb {
     background: #dc3545;
   }

   .recording-range::-moz-range-thumb {
     background: #dc3545;
   }

   .recording-range::-ms-thumb {
     background: #dc3545;
   }
  </style>

  <title>WebSocket demo</title>
</head>
<body class="bg-light">
  <script>
   // buffer, source, rate, startTime, startPos.
   let tapes = {};

   var ws = new WebSocket("wss://" + location.hostname + ":8765/");
   ws.binaryType = 'arraybuffer';

   ws.onopen = function(event) {
     console.log("connected");
   }

   ws.onmessage = function(e) {
     receiveTape(JSON.parse(e.data));
   }

   function _arrayBufferToBase64(buffer) {
     var binary = '';
     var bytes = new Uint8Array(buffer);
     var len = bytes.byteLength;
     for (var i = 0; i < len; i++) {
       binary += String.fromCharCode(bytes[ i ]);
     }
     return window.btoa(binary);
   }

   function _base64ToArrayBuffer(base64) {
     var binary_string = window.atob(base64);
     var len = binary_string.length;
     var bytes = new Uint8Array(len);
     for (let i = 0; i < len; i++) {
       bytes[i] = binary_string.charCodeAt(i);
     }
     return bytes.buffer;
   }

   function receiveTape(obj) {
     console.log("receiveTape");
     console.log(obj);
     let name = obj.name;
     if (obj.event === 'create') {
       // Create a local blank tape.
       let buffer = audioCtx.createBuffer(1, obj.length, audioCtx.sampleRate);
       let tape = {
         buffer,
         source: null,
         rate: 0,
         startPos: 0,
         startTime: audioCtx.currentTime
       }
       tapes[obj.name] = tape;
       addTape(obj.name, tape);
     } else if (obj.event == 'update') {
       // Update an existing tape with new data.
       let data = new Float32Array(_base64ToArrayBuffer(obj.data));
       let tape = tapes[name];
       let buffer = tape.buffer;
       buffer.copyToChannel(data, 0);
       if (tape.source) {
         tape.source.disconnect();
         tape.source = null;
       }
       setRate(tape, tape.rate);
     }
   }

   function sendCreate(name, tape) {
     console.log("sendCreate");
     ws.send(JSON.stringify({
       event: 'create',
       name,
       length: tape.buffer.length
     }));
   }

   function sendUpdate(name, tape) {
     console.log("sendUpdate");
     // not the most efficient encoding
     let encoded = _arrayBufferToBase64(tape.buffer.getChannelData(0).buffer);
     let serializable = {
       event: 'update',
       name,
       data: encoded
     }
     ws.send(JSON.stringify(serializable));
   }

   // Wild idea: what if the playback rate doubles as the recording rate?
   // so you can record at different rates, record backwards, etc.
   // then slider bubble can simply turn red for recording
   // Special case: if playback rate is 0 when you hit record, automatically change to 1?
   // Alternative terminology: 'loops' vs 'tapes'
   // Name idea: grouper looper. group's loops. etc.
   // Note: AudioBufferSourceNode.playbackRate is an AudioParam!
   // So is detune. Interesting.
   // TODO: websocket server for sharing tapes.
   // TODO: better audio encoding to avoid, possibly chunked tape transfer.

   // when tape is created or recorded, send to the server an object with the tape name and data.
   // the server sends this to each client.
   // when the client receives a new tape from the server, it adds it to the local list.

   let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
   let microphone;
   let micProcessor;

   const bufferSize = 0;

   const handleSuccess = (stream) => {
     microphone = audioCtx.createMediaStreamSource(stream);
   };

   navigator.mediaDevices.getUserMedia({ audio: true, video: false })
       .then(handleSuccess);

   function createTape() {
     // To satisfy Chrome's demands:
     if (audioCtx.state === "suspended")
       audioCtx.resume().then(_createTape);
     else
       _createTape();
   }

   // TODO make this an actual class
   function getPos(tape) {
     let pos = ((audioCtx.currentTime - tape.startTime) * tape.rate + tape.startPos);
     return ((pos % tape.buffer.duration) + tape.buffer.duration) % tape.buffer.duration;
   }

   function setRate(tape, rate) {
     // Reset startPos and startTime since we're changing playbackRate. Order matters.
     tape.startPos = getPos(tape);
     tape.startTime = audioCtx.currentTime;

     if (rate < 0) {
       // TODO Workaround this.
       console.log("negative playback rates not supported by web audio...");
       // TODO don't make a new reversed buffer every time; just do it when recording is done.
       let reverseBuffer = audioCtx.createBuffer(1, tape.buffer.length, audioCtx.sampleRate);
       let reversed = tape.buffer.getChannelData(0).slice(0).reverse();
       reverseBuffer.copyToChannel(reversed, 0);
       if (tape.source) {
         tape.source.disconnect();
         tape.source = null;
       }
       let source = audioCtx.createBufferSource();
       source.buffer = reverseBuffer;
       source.loop = true;
       source.connect(audioCtx.destination);
       source.start(0);
       tape.source = source;
       tape.source.playbackRate.value = -rate;
     } else if (rate === 0) {
       // Also not supported, but here's a workaround.
       if (tape.source) {
         tape.source.disconnect();
         tape.source = null;
       }
     } else {
       if (tape.rate < 0) {
         // Playing reversed.
         tape.source.disconnect();
         tape.source = null;
       }
       if (!tape.source) {
         let source = audioCtx.createBufferSource();
         source.buffer = tape.buffer;
         source.loop = true;
         source.connect(audioCtx.destination);
         source.start(0);
         tape.source = source;
       }
       tape.source.playbackRate.value = rate;
     }
     tape.rate = rate;
   }

   function _createTape() {
     let name = document.getElementById("tape-name").value;
     let length = parseFloat(document.getElementById("tape-length").value);
     console.log(name, length);
     let buffer = audioCtx.createBuffer(1, length * audioCtx.sampleRate, audioCtx.sampleRate);
     let tape = {
       buffer: buffer,
       source: null,
       rate: 0,
       startTime: audioCtx.currentTime,
       startPos: 0
     };
     tapes[name] = tape;
     sendCreate(name, tape);
     addTape(name, tape);
   }

   function addTape(name, tape) {
     let length = tape.buffer.duration;
     // Create new table entry from template.
     let table = document.getElementById("tape-table");
     let template = document.getElementById("tape-row-template");
     let entry = template.cloneNode(true);
     entry.hidden = false;
     entry.id = "";
     entry.getElementsByClassName("tape-name")[0].innerHTML = name;
     entry.getElementsByClassName("tape-length")[0].innerHTML = length;
     let pos = entry.getElementsByClassName("tape-position")[0];
     pos.id = `${name}-position`;
     let rate = entry.getElementsByClassName("tape-rate")[0];
     rate.value = tape.rate;
     rate.onchange = (e) => {
       let value = parseFloat(e.target.value);
       setRate(tape, value);
     }
     tape.dom = entry;
     table.appendChild(entry);

     // Add new source and destination options.
     for (let id of ["record-src", "record-dst"]) {
      let select = document.getElementById(id);
      let option = document.createElement("option");
      option.innerHTML = name;
      select.appendChild(option);
     }
   }

   function record() {
     console.log("start recording");
     let srcSelect = document.getElementById("record-src");
     let dstSelect = document.getElementById("record-dst");
     let src = null;
     let dst = dstSelect.options[dstSelect.selectedIndex].text;
     let dstName = "";
     if (srcSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else if (srcSelect.selectedIndex === 1) {
       src = microphone;
     } else {
       src = tapes[srcSelect.options[srcSelect.selectedIndex].text].source;
     }

     if (dstSelect.selectedIndex === 0) {
       console.log("error: no source selected.");
       return;
     } else {
       dstName = dstSelect.options[dstSelect.selectedIndex].text;
       dst = tapes[dstName];
     }

     dst.dom.getElementsByClassName("tape-position")[0].classList.add("recording-range");

     // Chrome bug requires us to add a dummy output:
     // https://bugs.chromium.org/p/chromium/issues/detail?id=327649#c15
     recorder = audioCtx.createScriptProcessor(bufferSize, 1, 1);
     recorder.connect(audioCtx.destination);
     src.connect(recorder);

     let pos = 0;
     recorder.onaudioprocess = (e) => {
       // TODO Allow recording to start anywhere, handle wrapping,
       // and maybe make stopping recording a separate action.
       if (pos > dst.buffer.length) {
         console.log('stop recording');

         dst.dom.getElementsByClassName("tape-position")[0].classList.remove("recording-range");

         src.disconnect(recorder);
         recorder.disconnect();
         recorder.onaudioprocess = null;

         // Browsers differ re. modifying the source's buffer, so let's just do this:
         if (dst.source) {
           dst.source.disconnect();
           dst.source = null;
         }
         setRate(dst, dst.rate);
         sendUpdate(dstName, dst);
         return;
       }
       let data = e.inputBuffer.getChannelData(0);
       dst.buffer.copyToChannel(data, 0, pos);
       pos += data.length;
     };
   }

   function updatePositions() {
     for (let name in tapes) {
       let tape = tapes[name];
       let slider = document.getElementById(`${name}-position`);
       let time = audioCtx.currentTime;
       slider.value = getPos(tape) / tape.buffer.duration * parseFloat(slider.max);
     }
     setTimeout(updatePositions, 30);
   }

   updatePositions();
  </script>
  <div class="container mt-4">
    <form>
      <div class="form-row align-items-center">
        <input id="tape-name" type="text" class="col-4 form-control my-1 mr-2" placeholder="Name" />
        <input id="tape-length" class="col-4 form-control my-1 mr-2" type="number" placeholder="Length (seconds)" />
        <button type="button" class="col-2 form-control btn btn-success" onclick="createTape()">Create tape</button><br/>
      </div>
    </form>
    <form>
      <div class="form-row align-items-center">
        <select id="record-src" class="col-4 form-control custom-select my-1 mr-2" placeholder="From">
          <option value="" disabled selected>Source</option>
          <option>Microphone</option>
        </select>
        <select id="record-dst" class="col-4 custom-select my-1 mr-2" placeholder="To">
          <option value="" disabled selected>Destination</option>
        </select>
        <button type="button" class="col-2 form-control btn btn-danger" onclick="record()">Record</button><br/>
      </div>
    </form>
    <hr>
    <h2>Tapes</h2>
    <table class="table">
      <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Position</th>
          <th scope="col">Length</th>
          <th scope="col">Playback Rate</th>
        </tr>
      </thead>
      <tbody id="tape-table">
        <tr id="tape-row-template" hidden>
          <th class="tape-name" scope="row">Foobar</th>
          <td><input type="range" class="tape-position custom-range" min="0" max="1000"></td>
          <td class="tape-length">5</td>
          <td><input class="tape-rate" type="number"></td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- for bootstrap -->
  <script src="jquery-3.4.1.slim.min.js"></script>
  <script src="bootstrap.bundle.min.js"></script>
</body>
</html>
